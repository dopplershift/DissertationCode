# -*- coding: utf-8 -*-
#!/usr/bin/env python

from collections import namedtuple
import numpy as np
import quantities as pq
import disser.scatter
import disser.units
import disser.tools
import disser.io
import dsd

ScatterInfo = namedtuple('ScatterInfo', 'z zdr kdp atten diff_atten temps')
def calc_scatter(qr, nr, dist_func, lam, temp):
    try:
        len(temp)
    except TypeError:
        temp = np.array([temp])
    d = np.linspace(0.01, 8., 100).reshape(-1, 1) * pq.millimeter
    dist = dist_func(d, nr, qr)
    z = np.empty((len(temp),) + qr.shape, dtype=d.dtype)
    kdp = np.empty_like(z)
    zdr = np.empty_like(z)
    atten = np.empty_like(z)
    diff_atten = np.empty_like(z)
    temps = np.empty_like(z)
    for i,t in enumerate(temp):
        scat = disser.scatter.bulk_scatter(lam, t, dist, d)
        kdp[i] = scat.kdp.rescale('deg/km').magnitude
        zdr[i] = disser.units.to_linear(scat.zdr)
        z[i] = disser.units.to_linear(scat.z)
        atten[i] = scat.atten.rescale('dB/km').magnitude
        diff_atten[i] = scat.diff_atten.rescale('dB/km').magnitude
        temps[i].fill(t)
    return ScatterInfo(z.flatten(), zdr.flatten(), kdp.flatten(), atten.flatten(), diff_atten.flatten(), temps.flatten())

def fit_z_attenuation(scatter, pol='H'):
    z = scatter.z
    atten = scatter_data.atten
    if pol == 'V':
        z = z / scatter.zdr # linear
        atten = atten - scatter.diff_atten # dB
    weights = (atten * atten).reshape(-1, 1)
    coeffs,fit = disser.tools.power_law_fit(z.reshape(-1, 1),
            atten.reshape(-1, 1), weights)
    return coeffs

def fit_kdp_attenuation(scatter, pol='H'):
    kdp = scatter.kdp
    if pol == 'H':
        atten = scatter.atten
    elif pol == 'V':
        atten = scatter.atten - scatter.diff_atten # dB
    elif pol == 'diff':
        atten = scatter.diff_atten
    weights = (atten * atten).reshape(-1, 1)
    coeffs,fit = disser.tools.linear_regression(kdp.reshape(-1, 1),
            atten.reshape(-1, 1), weights)
    return coeffs

def fit_all_attenuation(scatter, pol='H'):
    if pol == 'H':
        atten = scatter.atten
    elif pol == 'diff':
        atten = scatter.diff_atten
    weights = (atten * atten).reshape(-1, 1)
    coeffs,fit = disser.tools.power_law_fit(np.array([scatter.z, scatter.zdr,
        scatter.kdp]).T, atten.reshape(-1, 1), weights)
    return coeffs

# Model distribution parameters
# Use subset of data with actual rain
data = disser.io.ModelData('/home/rmay/radar_sim_git/data/commas_wz_3600.nc')
mask = (data.qr > 5e-4) & (data.nr > 1e2)
qr = data.qr[mask][::100]
qr = qr.rescale('g/m**3')
nr = data.nr[mask][::100]

# Scattering Calculations
za_fit_coeffs = dict()
ka_fit_coeffs = dict()
sc_fit_coeffs = dict()
lams = {10 * pq.cm : 'S', 5.55 * pq.cm : 'C', 3.21 * pq.cm : 'X'}
for l in lams:
    temp = 20
    scatter_data = calc_scatter(qr, nr, dsd.gamma_from_moments, l, temp)
    za_fit_coeffs[(lams[l], 'H')] = fit_z_attenuation(scatter_data, pol='H')
    za_fit_coeffs[(lams[l], 'V')] = fit_z_attenuation(scatter_data, pol='V')

    ka_fit_coeffs[(lams[l], 'H')] = fit_kdp_attenuation(scatter_data, pol='H')
    ka_fit_coeffs[(lams[l], 'V')] = fit_kdp_attenuation(scatter_data, pol='V')
    ka_fit_coeffs[(lams[l], 'diff')] = fit_kdp_attenuation(scatter_data,
            pol='diff')

    sc_fit_coeffs[(lams[l], 'H')] = fit_all_attenuation(scatter_data, pol='H')
    sc_fit_coeffs[(lams[l], 'diff')] = fit_all_attenuation(scatter_data,
            pol='diff')

with open('fit_coeffs.py', 'w') as outfile:
    from datetime import datetime
    outfile.write('# Autogenerated on %s\n' % datetime.utcnow())
    outfile.write('za_coeffs = %s\n' % repr(za_fit_coeffs))
    outfile.write('ka_coeffs = %s\n' % repr(ka_fit_coeffs))
    outfile.write('sc_coeffs = %s\n' % repr(sc_fit_coeffs))
